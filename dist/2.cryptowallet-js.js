(window.webpackJsonpcryptowallet_js=window.webpackJsonpcryptowallet_js||[]).push([[2],{1:function(e,t,n){"use strict";n.r(t);var i,r,s=n(126),o=n(127),a=n(239),c=n(140),d=n(342),h=n(95),p=n(170),u=n.n(p),l=n(176);r=i||(i={}),(r.SDKS||(r.SDKS={})).GenericSDK=class{constructor(e){this.bitcoinlib=d,this.networks=l,this.bip39=a,this.wif=h,this.axios=u.a,e&&(this.networkInfo=e)}generateHDWallet(e,t){if(!this.bip39.validateMnemonic(e))throw new TypeError("Invalid entropy");const n=this.networkInfo?this.networkInfo:this.networks[t];if(!n)throw new Error("Invalid network");const i=n.bip,r=c.fromMasterSeed(this.bip39.mnemonicToSeed(e));let s,o,a=0;return n.segwit?(s=r.derive(`m/49'/${i}'/0'/0`),o=r.derive(`m/49'/${i}'/0'/1`),a=49):"REGTEST"===n.name?(s=r.derive("m/0"),o=r.derive("m/1"),a=0):(s=r.derive(`m/44'/${i}'/0'/0`),o=r.derive(`m/44'/${i}'/0'/1`),a=44),{bip:a,ext:s.toJSON(),int:o.toJSON(),type:i,network:n}}generateKeyPair(e,t,n){if(!e.network.connect)throw new Error("Invalid wallet type");let i=c.fromJSON(e.ext);n&&(i=c.fromJSON(e.int));const r=i.deriveChild(t);let s=this.bitcoinlib.payments.p2sh({redeem:this.bitcoinlib.payments.p2wpkh({pubkey:r.publicKey,network:e.network.connect}),network:e.network.connect});e.network.segwit||(s=this.bitcoinlib.payments.p2pkh({pubkey:r.publicKey,network:e.network.connect}));const{address:o}=s;return{address:o,publicKey:r.publicKey.toString("hex"),privateKey:this.wif.encode(e.network.connect.wif,r.privateKey,!0),derivationPath:`m/${e.bip}'/${e.type}'/0'/0/${t}`,type:e.network.name,network:e.network,change:n}}generateAddress(e,t,n){if(!e.network.connect)throw new Error("Invalid wallet type");let i=c.fromJSON(e.ext);n&&(i=c.fromJSON(e.int));const r=i.deriveChild(t);let s=this.bitcoinlib.payments.p2sh({redeem:this.bitcoinlib.payments.p2wpkh({pubkey:r.publicKey,network:e.network.connect}),network:e.network.connect});e.network.segwit||(s=this.bitcoinlib.payments.p2pkh({pubkey:r.publicKey,network:e.network.connect}));const{address:o}=s;return{address:o,index:t,type:e.network.name,change:n}}importWIF(e,t){const n=this.networkInfo?this.networkInfo:this.networks[t];if(!n||!n.connect)throw new Error("Invalid network type");const i=this.bitcoinlib.ECPair.fromWIF(e,n.connect);let r=this.bitcoinlib.payments.p2sh({redeem:this.bitcoinlib.payments.p2wpkh({pubkey:i.publicKey,network:n.connect}),network:n.connect});n.segwit||(r=this.bitcoinlib.payments.p2pkh({pubkey:i.publicKey,network:n.connect}));const{address:s}=r;return{address:s,keyPair:i}}broadcastTx(e,t){const n=this.networkInfo?this.networkInfo:this.networks[t];if(!n||!n.connect)throw new Error("Invalid network type");return new Promise((t,i)=>{n.segwit?this.axios.post(n.broadcastUrl,{tx_hex:e}).then(e=>{const n=e.data.data.txid;return t(n)}).catch(e=>i(new Error("Transaction failed"))):this.axios.post(`${n.discovery}/tx/send`,{rawtx:e}).then(e=>{const{txid:n}=e.data;return t(n)}).catch(e=>i(new Error("Transaction failed")))})}validateAddress(e,t){const n=this.networkInfo?this.networkInfo:this.networks[t];try{this.bitcoinlib.address.toOutputScript(e,n.connect)}catch(e){return!1}return!0}getTransactionFee(e){const t=this.networkInfo?this.networkInfo:this.networks[e];if(!t||!t.connect)throw new Error("Invalid network type");return new Promise((e,n)=>{const i=t.feeApi;this.axios.get(i).then(t=>{e({high:t.data.high_fee_per_kb/1e3,medium:t.data.medium_fee_per_kb/1e3,low:t.data.low_fee_per_kb/1e3})}).catch(e=>n(e.message))})}createRawTx(e,t,n,i,r,a,c,d){if(!i||!i.network||!i.network.connect)throw new Error("Invalid wallet type");if(!this.validateAddress(r,i.network.name))throw new Error(`Invalid to address "${r}"`);const h=c,p=Math.floor(1e8*a),u=i.network;let l;return new Promise(async(c,w)=>{if(0===n.length)return w(new Error("You don't have enough balance to cover transaction"));let m=0;for(let e=0;e<n.length;e+=1)m+=n[e].value;if(m-p>0){let w=[{address:r,value:p}],m=s(n,w,h);if(t.length>1){t.forEach(e=>{const t={address:e};w.push(t)});const{inputs:e}=m;m=o(e,w,h)}d&&(m=o(n,w=[{address:r}],h));const{inputs:E,outputs:f}=m;let{fee:b}=m;const y=[],v=[],k=[];E.forEach(t=>{e.forEach(e=>{let n;if(t.address===e.address){e.change?(n=this.generateKeyPair(i,e.index,!0),k.push(e)):n=this.generateKeyPair(i,e.index);const t=this.bitcoinlib.ECPair.fromWIF(n.privateKey,u.connect),r=this.bitcoinlib.payments.p2wpkh({pubkey:t.publicKey,network:u.connect}),s=this.bitcoinlib.payments.p2sh({redeem:r,network:u.connect});y.push(t),v.push(s)}})});const g=new this.bitcoinlib.TransactionBuilder(u.connect);g.setVersion(1),E.forEach(e=>{g.addInput(e.txid,e.vout)});let T=0;d?(f.forEach(e=>{T+=e.value}),g.addOutput(r,T)):f.forEach(e=>{let{address:n}=e;e.address||([n]=t),g.addOutput(n,e.value)});let I=0;E.forEach(e=>{i.network.segwit?g.sign(I,y[I],v[I].redeem.output,void 0,E[I].value):g.sign(I,y[I]),I+=1}),l=g.build().toHex();const S=[],_=1e3,x=E.map(e=>(S.push(e.address),e.txid)),A={fee:b/=1e8,change:t,receiver:[r],confirmed:!1,inputs:x,confirmations:0,hash:g.build().getId(),blockHeight:-1,sent:!0,value:a,sender:S,receivedTime:(new Date).getTime()/_,confirmedTime:void 0};return d&&(A.value=T/1e8),c({changeInputUsed:k,transaction:A,hexTx:l,utxo:E})}return w(new Error("You don't have enough Satoshis to cover the miner fee."))})}verifyTxSignature(e,t){const n=this.networkInfo?this.networkInfo:this.networks[t];if(!n||!n.connect)throw new Error("Invalid network type");const i=e.pubKeys.map(e=>this.bitcoinlib.ECPair.fromPublicKey(Buffer.from(e,"hex"),n.connect)),r=this.bitcoinlib.Transaction.fromHex(e.txHex),s=[];return r.ins.forEach((e,t)=>{const n=i[t],o=this.bitcoinlib.payments.p2pkh({pubkey:n.publicKey,input:e.script}),a=this.bitcoinlib.script.signature.decode(o.signature),c=r.hashForSignature(t,o.output,a.hashType);s.push(n.verify(c,a.signature))}),s.every(e=>!0===e)}accountDiscovery(e,t){if(!e||!e.network||!e.network.connect)throw new Error("Invalid wallet type");const n=e.network.discovery;let i=[];const r=[];let s=[],o=!1;t&&(o=!0);const a=(e,t)=>{const o=`${n}/addr/${e}?noTxList=1`;return new Promise(async(n,a)=>{try{const c=await this.axios.get(o);if(!c.data)return a(new Error("API ERROR"));const d={address:e,received:c.data.totalReceived,balance:c.data.balance,index:t};return d.received>0?(i.push(d),r.push(d.index)):s.push(d.index),n(d)}catch(e){return a(e)}})};return new Promise(async(n,c)=>{let d=0;const h=async()=>{const n=[];for(let i=d;i<d+20;i+=1){const r=i,s=this.generateKeyPair(e,r,t);n.push(a(s.address,r))}try{await Promise.all(n)}catch(e){throw e}if(s.length>0&&r.length>0){const e=Math.max(...r)+1;d=e}s.length<20&&(s=[],await h())};try{await h()}catch(e){return c(e)}const p={change:o,nextAddress:d},u=i;return t&&(p.used=u,i=i.filter(e=>0!==e.balance)),p.active=i,n(p)})}getTransactionHistory(e,t,n,i){const r=this.networkInfo?this.networkInfo:this.networks[t];if(!r||!r.connect)throw new Error("Invalid network");if(!e.every(e=>this.validateAddress(e,t)))throw new Error("Invalid address used");return new Promise((t,s)=>{const o=`${r.discovery}/addrs/txs`;this.axios.post(o,{addrs:e.toString(),from:n,to:i}).then(r=>{if(0===r.data.totalItems)return t();let s=!1;r.data.totalItems>i&&(s=!0);const o=r.data.items,a=[];o.forEach(t=>{let n=!1;t.confirmations>5&&(n=!0);let i=!1,r=0;const s=[],o=[],c=[],d=[];t.vin.forEach(t=>{e.includes(t.addr)&&(i=!0),c.push(t.addr),d.push(t.txid)}),t.vout.forEach(t=>{const n=t.scriptPubKey.addresses,a=parseFloat(t.value);n.forEach(t=>{t[0],i&&!e.includes(t)?(o.push(t),r+=a):!i&&e.includes(t)?(r+=a,o.push(t)):s.push(t)})});const h={sent:i,value:r,change:s,confirmed:n,inputs:d,confirmations:t.confirmations,hash:t.txid,blockHeight:t.blockheight,fee:t.fees,sender:c,receiver:o,receivedTime:t.time,confirmedTime:t.blocktime};a.push(h)});const c={more:s,from:n,to:i,address:e,totalTransactions:r.data.totalItems,txs:a};return t(c)}).catch(e=>s(new Error("API failed to get transaction history")))})}getBalance(e,t){const n=this.networkInfo?this.networkInfo:this.networks[t];if(!n||!n.connect)throw new Error("Invalid network");if(!e.every(e=>this.validateAddress(e,t)))throw new Error("Invalid address used");return new Promise((t,i)=>{let r=0;const s=`${n.discovery}/addrs/utxo`;this.axios.post(s,{addrs:e.toString()}).then(e=>0===e.data.length?t(r=0):(e.data.forEach(e=>{r+=e.amount}),t(r))).catch(e=>i(new Error("API failed to return a balance")))})}};var w,m=i.SDKS.GenericSDK;!function(e){!function(e){!function(e){e.BitcoinSDK=class extends m{constructor(e){super(e)}generateSegWitAddress(e){if(!e.network||!e.network.connect)throw new Error("Invalid keypair type");const t=this.bitcoinlib.ECPair.fromWIF(e.privateKey,e.network.connect),{address:n}=this.bitcoinlib.payments.p2wpkh({pubkey:t.publicKey,network:e.network.connect});return n}generateSegWitP2SH(e){if(!e.network||!e.network.connect)throw new Error("Invalid keypair type");const t=this.bitcoinlib.ECPair.fromWIF(e.privateKey,e.network.connect),{address:n}=this.bitcoinlib.payments.p2sh({redeem:this.bitcoinlib.payments.p2wpkh({pubkey:t.publicKey,network:e.network.connect}),network:e.network.connect});return n}generateSegWit3of4MultiSigAddress(e,t,n,i,r){const s=this.networkInfo?this.networkInfo:this.networks[r];if(!s||!s.connect)throw new Error("Invalid network");try{const r=[e,t,n,i].map(e=>Buffer.from(e,"hex")),{address:o}=this.bitcoinlib.payments.p2wsh({redeem:this.bitcoinlib.payments.p2ms({pubkeys:r,m:3,network:s.connect}),network:s.connect});return o}catch(e){throw new Error("Invalid public key used")}}generateP2SHMultiSig(e,t){const n=this.networkInfo?this.networkInfo:this.networks[t];if(!n||!n.connect)throw new Error("Invalid network");try{const t=e.map(e=>Buffer.from(e,"hex")),{address:i}=this.bitcoinlib.payments.p2sh({redeem:this.bitcoinlib.payments.p2wsh({redeem:this.bitcoinlib.payments.p2ms({pubkeys:t,m:t.length,network:n.connect}),network:n.connect}),network:n.connect});return i}catch(e){throw new Error("Invalid public key used")}}getUTXOs(e,t){const n=this.networkInfo?this.networkInfo:this.networks[t];if(!n||!n.connect)throw new Error("Invalid network");if(!e.every(e=>this.validateAddress(e,t)))throw new Error("Invalid address used");return new Promise((t,i)=>{const r=`${n.discovery}/addrs/utxo`;this.axios.post(r,{addrs:e.toString()}).then(e=>{const n=[];return 0===e.data.length?t(n):(e.data.forEach(e=>{const t=e;t.value=e.satoshis,n.push(t)}),t(n))}).catch(e=>i(new Error("Failed to fetch UTXOs")))})}createTxToMany(e,t,n,i,r,a,c){if(!i.network||!i.network.connect)throw new Error("Invalid wallet type");const d=c,h=a.reduce((e,t)=>e+t),p=Math.floor(1e8*h),u=i.network;let l;return new Promise(async(c,w)=>{if(0===n.length)return w(new Error("You don't have enough balance to cover transaction"));let m=0;for(let e=0;e<n.length;e+=1)m+=n[e].value;if(m-p-d>0){const p=[],w=(e,t)=>{const n={address:e,value:Math.floor(1e8*a[t])};p.push(n)};r.forEach(w);let m=s(n,p,d);if(t.length>1){t.forEach(e=>{const t={address:e};p.push(t)});const{inputs:e}=m;m=o(e,p,d)}const{inputs:E,outputs:f}=m;let{fee:b}=m;const y=[],v=[],k=[];E.forEach(t=>{e.forEach(e=>{let n;if(t.address===e.address){e.change?(n=this.generateKeyPair(i,e.index,!0),k.push(e)):n=this.generateKeyPair(i,e.index);const t=this.bitcoinlib.ECPair.fromWIF(n.privateKey,u.connect),r=this.bitcoinlib.payments.p2wpkh({pubkey:t.publicKey,network:u.connect}),s=this.bitcoinlib.payments.p2sh({redeem:r,network:u.connect});y.push(t),v.push(s)}})});const g=new this.bitcoinlib.TransactionBuilder(u.connect);g.setVersion(1),E.forEach(e=>{g.addInput(e.txid,e.vout)}),f.forEach(e=>{let{address:n}=e;e.address||([n]=t),g.addOutput(n,e.value)});let T=0;E.forEach(e=>{i.network.segwit?g.sign(T,y[T],v[T].redeem.output,void 0,E[T].value):g.sign(T,y[T]),T+=1}),l=g.build().toHex();const I=[];E.forEach(e=>{I.push(e.address)});const S=1e3,_={fee:b/=1e8,change:t,receiver:[r],confirmed:!1,confirmations:0,hash:g.build().getId(),blockHeight:-1,sent:!0,value:h,sender:I,receivedTime:(new Date).getTime()/S,confirmedTime:void 0};return c({changeInputUsed:k,transaction:_,hexTx:l,utxo:E})}return w(new Error("You don't have enough Satoshis to cover the miner fee."))})}create1t1tx(e,t,n,i,r,s){if(!e.network||!e.network.connect)throw new Error("Invalid keypair");const o=this.bitcoinlib.ECPair.fromWIF(e.privateKey,e.network.connect),a=this.bitcoinlib.payments.p2wpkh({pubkey:o.publicKey,network:e.network.connect}),c=this.bitcoinlib.payments.p2sh({redeem:a,network:e.network.connect}),d=new this.bitcoinlib.TransactionBuilder(e.network.connect);return d.setVersion(1),d.addInput(t,n),d.addOutput(r,s),e.network.segwit?d.sign(0,o,c.redeem.output,void 0,i):d.sign(0,o),d.build().toHex()}create2t2tx(e,t,n,i,r,s){if(!(e.network&&e.network.connect&&t.network&&t.network.connect))throw new Error("Invalid keypair");const o=this.bitcoinlib.ECPair.fromWIF(e.privateKey,e.network.connect),a=this.bitcoinlib.ECPair.fromWIF(t.privateKey,t.network.connect),c=this.bitcoinlib.payments.p2wpkh({pubkey:o.publicKey,network:e.network.connect}),d=this.bitcoinlib.payments.p2wpkh({pubkey:a.publicKey,network:t.network.connect}),h=this.bitcoinlib.payments.p2sh({redeem:c,network:e.network.connect}),p=this.bitcoinlib.payments.p2sh({redeem:d,network:t.network.connect}),u=new this.bitcoinlib.TransactionBuilder(e.network.connect);return u.setVersion(1),u.addInput(n.txid,n.vout),u.addInput(i.txid,i.vout),u.addOutput(r.address,r.amount),u.addOutput(s.address,s.amount),e.network.segwit?u.sign(0,o,h.redeem.output,void 0,r.amount):u.sign(0,o),t.network.segwit?u.sign(1,a,p.redeem.output,void 0,s.amount):u.sign(1,a),u.build().toHex()}}}(e.Bitcoin||(e.Bitcoin={}))}(e.SDKS||(e.SDKS={}))}(w||(w={}));var E,f=w.SDKS.Bitcoin.BitcoinSDK,b=n(398),y=n(177),v=n(102),k=n(187);!function(e){!function(e){!function(e){e.EthereumSDK=class extends m{constructor(e){super(e),this.Bip=b,this.ethereumlib=y,this.Web3=k,this.api=e}generateKeyPair(e,t){if(!e.network||e.network.connect)throw new Error("Invalid wallet type");const n=this.Bip.fromExtendedKey(e.ext.xpriv).deriveChild(t);return{publicKey:n.getWallet().getPublicKeyString(),address:n.getWallet().getChecksumAddressString(),derivationPath:`m/44'/60'/0'/0/${t}`,privateKey:n.getWallet().getPrivateKeyString(),type:"Ethereum",network:this.api||e.network}}generateAddress(e,t){if(!e.network||e.network.connect)throw new Error("Invalid wallet type");return{index:t,address:this.Bip.fromExtendedKey(e.ext.xpriv).deriveChild(t).getWallet().getChecksumAddressString(),type:e.network.name}}validateAddress(e){return this.Web3.utils.isAddress(e.toLowerCase())}getTransactionFee(e){if(!this.networks[e]||this.networks[e].connect)throw new Error("Invalid network");return new Promise((t,n)=>{const i=this.api?this.api.feeApi:this.networks[e].feeApi;this.axios.get(i).then(e=>t({high:e.data.high_gas_price,medium:e.data.medium_gas_price,low:e.data.low_gas_price,txHigh:21e3*e.data.high_gas_price/1e18,txMedium:21e3*e.data.medium_gas_price/1e18,txLow:21e3*e.data.low_gas_price/1e18})).catch(e=>n(e.message))})}importWIF(e,t){const n=Buffer.from(e,"hex"),i=this.ethereumlib.fromPrivateKey(n);return{publicKey:`0x${i.getPublicKeyString()}`,address:i.getChecksumAddressString(),privateKey:`0x${i.getPrivateKey().toString("hex")}`,type:this.networks[t].name}}createEthTx(e,t,n,i,r=25e3){const s=Buffer.from(e.privateKey.substr(2),"hex"),o=new this.Web3(e.network.provider);return new Promise(async(a,c)=>{const d=await o.eth.getTransactionCount(e.address),h=n.toString(),p=i.toString(),u=new v({nonce:d,gasPrice:o.utils.toHex(p),gasLimit:o.utils.toHex(r),to:t,value:o.utils.toHex(o.utils.toWei(h)),chainId:e.network.chainId});u.sign(s);const l=`0x${u.serialize().toString("hex")}`;return a({transaction:{hash:o.utils.sha3(l),fee:o.utils.fromWei((i*r).toString(),"ether"),receiver:t,confirmed:!1,confirmations:0,blockHeight:-1,sent:!0,value:n,sender:e.address,receivedTime:(new Date).getTime()/1e3,confirmedTime:(new Date).getTime()/1e3},hexTx:l})})}broadcastTx(e,t){const n=this.api?this.api.provider:this.networks[t].provider,i=new this.Web3(n);return new Promise(async(t,n)=>{i.eth.sendSignedTransaction(e,(e,i)=>e?n(e):t({hash:i}))})}verifyTxSignature(e){const t=new v(e);return this.VerifyTx=e,!!t.verifySignature()}getTransactionHistory(e,t,n,i){const r=[],s=i=>new Promise(async(s,o)=>{let a;a=this.api?`${this.api.etherscan}?module=account&action=txlist&address=${i}&startblock=${n}&sort=desc`+(this.api.etherscan?`&apikey=${this.api.etherscanKey}`:null):`${this.networks[t].getTranApi+i}&startblock=${n}&sort=desc&apikey=${this.networks.ethToken}`,await this.axios.get(a).then(async t=>t.data.result?(t.data.result.forEach(t=>{let n=t.to,i=!1,s=!1,o=!1;t.from===e[0].toLowerCase()&&(i=!0),t.confirmations>11&&(s=!0),t.to||(n=t.contractAddress,o=!0);const a={sent:i,receiver:n,contractCall:o,confirmed:s,hash:t.hash,blockHeight:t.blockNumber,fee:(t.cumulativeGasUsed/1e9).toString(),value:t.value/1e18,sender:t.from,receivedTime:t.timeStamp,confirmedTime:t.timeStamp,confirmations:t.confirmations};r.push(a)}),s()):s()).catch(e=>o(e))});return new Promise(async(t,n)=>{const i=[];e.forEach(async e=>{i.push(new Promise(async(t,n)=>t(s(e))))});try{await Promise.all(i)}catch(e){return n(e)}return t({addresses:e,totalTransactions:r.length,txs:r})})}async getERC20History(e){const t=`${this.api.etherscan}/?module=account&action=tokentx&address=${e}&sort=desc`+(this.api.etherscan?`&apikey=${this.api.etherscanKey}`:null);return(await this.axios.get(t)).data.result.map(t=>({sent:t.from===e.toLowerCase(),receiver:t.to,confirmed:t.confirmations>11,hash:t.hash,blockHeight:t.blockNumber,gasPrice:t.gasPrice,gasLimit:t.gasLimit,gasUsed:t.gasUsed,value:t.value/10**t.tokenDecimal,sender:t.from,confirmedTime:t.timeStamp,confirmations:t.confirmations,tokenName:t.tokenName,tokenSymbol:t.tokenSymbol,tokenDecimal:t.tokenDecimal,contractAddress:t.contractAddress}))}getBalance(e,t){let n=0;const i=[],r=e=>new Promise(async(i,r)=>{let s;s=this.api?`${this.api.etherscan}?module=account&action=balance&address=${e}&tag=latest`+(this.api.etherscan?`&apikey=${this.api.etherscanKey}`:null):`${this.networks[t].getBalanceApi+e}&tag=latest&apikey=${this.networks.ethToken}`,await this.axios.get(s).then(e=>{n+=e.data.result,i()}).catch(e=>r(e))});return new Promise(async(t,s)=>{e.forEach(e=>{i.push(new Promise(async(t,n)=>t(r(e))))});try{await Promise.all(i)}catch(e){return s(e)}return t(n<1e12?0:n/1e18)})}accountDiscovery(e,t){const n=[];for(let t=0;t<10;t+=1){const i={address:this.generateKeyPair(e,t).address,index:t,type:e.network.name};n.push(i)}return n}}}(e.Ethereum||(e.Ethereum={}))}(e.SDKS||(e.SDKS={}))}(E||(E={}));var g=E.SDKS.Ethereum.EthereumSDK;var T,I=[{constant:!0,inputs:[],name:"name",outputs:[{name:"",type:"string"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_spender",type:"address"},{name:"_value",type:"uint256"}],name:"approve",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[],name:"totalSupply",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_from",type:"address"},{name:"_to",type:"address"},{name:"_value",type:"uint256"}],name:"transferFrom",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[],name:"decimals",outputs:[{name:"",type:"uint8"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[{name:"_owner",type:"address"}],name:"balanceOf",outputs:[{name:"balance",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[],name:"symbol",outputs:[{name:"",type:"string"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_to",type:"address"},{name:"_value",type:"uint256"}],name:"transfer",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[{name:"_owner",type:"address"},{name:"_spender",type:"address"}],name:"allowance",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{payable:!0,stateMutability:"payable",type:"fallback"},{anonymous:!1,inputs:[{indexed:!0,name:"owner",type:"address"},{indexed:!0,name:"spender",type:"address"},{indexed:!1,name:"value",type:"uint256"}],name:"Approval",type:"event"},{anonymous:!1,inputs:[{indexed:!0,name:"from",type:"address"},{indexed:!0,name:"to",type:"address"},{indexed:!1,name:"value",type:"uint256"}],name:"Transfer",type:"event"}];!function(e){!function(e){!function(e){e.ERC20SDK=class{constructor(e){this.json=I,this.networks=l,this.axios=p,this.Tx=v,this.Web3=k,e&&(this.api=e)}generateERC20Wallet(e,t,n,i,r){if(!this.Web3.utils.isAddress(i.toLowerCase()))throw new Error("This is not a valid ERC20 contract address");return{decimals:r,address:e.address,network:e.network,name:t,type:e.type,symbol:n,contract:i}}broadcastTx(e,t){const n=this.api?this.api.provider:this.networks[t].provider,i=new this.Web3(n);return new Promise(async(t,n)=>{i.eth.sendSignedTransaction(e,(e,i)=>e?n(e):t({hash:i}))})}estimateGas(e,t,n,i){const r=this.api?this.api.provider:this.networks[i].provider,s=new(new this.Web3(r).eth.Contract)(this.json,e.contract),o=(n*10**e.decimals).toString();return new Promise(async(n,i)=>{s.methods.transfer(t,o).estimateGas({from:e.address},(e,t)=>e?i(e):n(t))})}transfer(e,t,n,i,r){const s=new(new this.Web3(e.network.provider).eth.Contract)(this.json,e.contract),o=(i*10**e.decimals).toString(),a=s.methods.transfer(n,o).encodeABI();return this.createTx(e,t,a,r,n,i)}approveAccount(e,t,n,i,r){const s=new(new this.Web3(e.network.provider).eth.Contract)(this.json,e.contract),o=(i*10**e.decimals).toString(),a=s.methods.approve(n,o).encodeABI();return this.createTx(e,t,a,r)}transferAllowance(e,t,n,i,r){return new Promise(async(s,o)=>{const a=new(new this.Web3(e.network.provider).eth.Contract)(this.json,e.contract);if(await this.checkAllowance(e,n)>=i){const o=(i*10**e.decimals).toString(),c=a.methods.transferFrom(n,e.address,o).encodeABI();return s(this.createTx(e,t,c,r))}return s("You don't have enough allowance")})}checkAllowance(e,t){return this.wallet=e,new Promise(async(n,i)=>{const r=new(new this.Web3(e.network.provider).eth.Contract)(this.json,e.contract);return n(await r.methods.allowance(t,e.address).call())})}getBalance(e){return this.wallet=e,new Promise(async(t,n)=>{const i=this.api?this.api.provider:e.network.provider,r=new(new this.Web3(i).eth.Contract)(this.json,e.contract);return t(await r.methods.balanceOf(e.address).call()/10**e.decimals)})}getTokenData(e,t){return new Promise(async(n,i)=>{const r=this.api?this.api.provider:this.networks[t].provider,s=new this.Web3(r),o=this.json;if("0x"===await s.eth.getCode(e))return i(new Error("This is not a valid ERC20 contract address"));const a=new s.eth.Contract(o,e);await a.methods.balanceOf("0xcc345035D14458B3C012977f96fA1E116760D60a").call().catch(e=>i(new Error("Not a valid ERC20 contract address")));try{const e=await a.methods.decimals().call();return n({name:await a.methods.name().call(),symbol:await a.methods.symbol().call(),decimals:e})}catch(e){return n()}})}getTransactionHistory(e,t){return new Promise(async(n,i)=>{const r=this.api?`${this.api.etherscan}?module=account&action=tokentx&contractaddress=`:this.networks[e.network.name].getErc20TranApi,s=this.api?this.api.etherscanKey:this.networks.ethToken;let o=`${r+e.contract}&address=${e.address}&startblock=${t}&sort=desc`+(s?`&apikey=${s}`:null);void 0===t&&(o=`${r+e.contract}&address=${e.address}&sort=desc`+(s?`&apikey=${s}`:null)),await this.axios.get(o).then(async t=>{if(!t.data.result)return n();const i=[];return t.data.result.forEach(t=>{const n=t.to;let r=!1,s=!1;t.from===e.address.toLowerCase()&&(r=!0),t.confirmations>11&&(s=!0);const o={sent:r,receiver:n,confirmed:s,hash:t.hash,blockHeight:t.blockNumber,fee:t.cumulativeGasUsed/1e9,value:t.value/10**e.decimals,sender:t.from,confirmedTime:t.timeStamp,confirmations:t.confirmations};i.push(o)}),n(i)}).catch(e=>i(e))})}createTx(e,t,n,i,r,s){const o=new this.Web3(e.network.provider);return new Promise(async(a,c)=>{const d=await o.eth.getTransactionCount(e.address),h=i.toString();let p=1e5;if(r&&s)try{p=await this.estimateGas(e,r,s,t.network.name)}catch(e){c(e)}const u=new this.Tx({nonce:d,gasPrice:o.utils.toHex(h),gasLimit:o.utils.toHex(1e5),to:e.contract,value:0,data:n,chainId:e.network.chainId}),l=Buffer.from(t.privateKey.substr(2),"hex");u.sign(l);const w=`0x${u.serialize().toString("hex")}`;return a({hexTx:w,transaction:{fee:(i*p).toString(),hash:o.utils.sha3(w),receiver:r,confirmed:!1,confirmations:0,blockHeight:-1,sent:!0,value:s,sender:e.address,receivedTime:(new Date).getTime()/1e3,confirmedTime:(new Date).getTime()/1e3}})})}}}(e.ERC20||(e.ERC20={}))}(e.SDKS||(e.SDKS={}))}(T||(T={}));var S,_=T.SDKS.ERC20.ERC20SDK;(S||(S={})).createSDK=function(e,t){switch(e){case"Bitcoin":return new f(t);case"Ethereum":return new g(t);case"ERC20":return new _(t);default:return new f(t)}};var x,A=S;!function(e){(x||(x={})).CryptoWalletJS=class{constructor(){this.SDKFactory=A}}}();t.default=x.CryptoWalletJS},176:function(e,t,n){"use strict";n.r(t),function(e){n.d(t,"ethToken",function(){return i}),n.d(t,"cryptocompare",function(){return r}),n.d(t,"BITCOIN",function(){return s}),n.d(t,"BITCOIN_TESTNET",function(){return o}),n.d(t,"LITECOIN",function(){return a}),n.d(t,"LITECOIN_TESTNET",function(){return c}),n.d(t,"DASH",function(){return d}),n.d(t,"DASH_TESTNET",function(){return h}),n.d(t,"DOGECOIN",function(){return p}),n.d(t,"DOGECOIN_TESTNET",function(){return u}),n.d(t,"VIACOIN",function(){return l}),n.d(t,"VIACOIN_TESTNET",function(){return w}),n.d(t,"ETHEREUM",function(){return m}),n.d(t,"ETHEREUM_ROPSTEN",function(){return E}),n.d(t,"ETHEREUM_RINKEBY",function(){return f}),n.d(t,"ETHEREUM_KOVAN",function(){return b}),n.d(t,"ETHEREUM_GOERLI",function(){return y}),n.d(t,"REGTEST",function(){return v});const i=e.env.ETHERSCAN_API_KEY,r=e.env.CRYPTOCOMPARE_API_KEY,s={name:"BITCOIN",bip:0,segwit:!0,discovery:e.env.BITCOIN_DISCOVERY,broadcastUrl:e.env.BITCOIN_BROADCAST,feeApi:e.env.BITCOIN_FEE,connect:{messagePrefix:"Bitcoin Signed Message:\n",bech32:"bc",bip32:{private:76066276,public:76067358},pubKeyHash:0,scriptHash:5,wif:128}},o={name:"BITCOIN_TESTNET",type:"testnet",bip:1,segwit:!0,discovery:e.env.BITCOIN_TESTNET_DISCOVERY,broadcastUrl:e.env.BITCOIN_TESTNET_BROADCAST,feeApi:e.env.BITCOIN_TESTNET_FEE,connect:{messagePrefix:"Bitcoin Signed Message:\n",bech32:"tb",bip32:{public:70617039,private:70615956},pubKeyHash:111,scriptHash:196,wif:239}},a={name:"LITECOIN",bip:2,segwit:!0,discovery:e.env.LITECOIN_DISCOVERY,broadcastUrl:e.env.LITECOIN_BROADCAST,feeApi:e.env.LITECOIN_FEE,connect:{messagePrefix:"Litecoin Signed Message:\n",bip32:{public:27108450,private:27106558},pubKeyHash:48,scriptHash:50,wif:176}},c={name:"LITECOIN_TESTNET",type:"litecoin testnet",bip:1,segwit:!0,discovery:e.env.LITECOIN_TESTNET_DISCOVERY,broadcastUrl:e.env.LITECOIN_TESTNET_BROADCAST,feeApi:e.env.LITECOIN_TESTNET_FEE,connect:{messagePrefix:"Litecoin Signed Message:\n",bip32:{private:70709117,public:70711009},pubKeyHash:111,scriptHash:58,wif:239}},d={name:"DASH",bip:5,segwit:!1,discovery:e.env.DASH_DISCOVERY,feeApi:e.env.DASH_FEE,connect:{messagePrefix:"unused",bip32:{public:76067358,private:76066276},pubKeyHash:76,scriptHash:16,wif:204}},h={name:"DASH_TESTNET",bip:1,segwit:!1,discovery:e.env.DASH_TESTNET_DISCOVERY,feeApi:e.env.DASH_TESTNET_FEE,connect:{messagePrefix:"unused",bip32:{public:70617039,private:70615956},pubKeyHash:140,scriptHash:19,wif:239}},p={name:"DOGECOIN",bip:3,segwit:!1,connect:{messagePrefix:"Dogecoin Signed Message:\n",bip32:{public:49990397,private:49988504},pubKeyHash:30,scriptHash:22,wif:158}},u={name:"DOGECOIN_TESTNET",bip:1,segwit:!1,connect:{messagePrefix:"Dogecoin Signed Message:\n",bip32:{private:70427203,public:70429096},wif:241,public:113,scripthash:196}},l={name:"VIACOIN",segwit:!1,connect:{messagePrefix:"Viacoin Signed Message:\n",bip32:{public:76067358,private:76066276},pubKeyHash:71,scriptHash:33,wif:199}},w={name:"VIACOIN_TESTNET",segwit:!1,connect:{messagePrefix:"Viacoin Signed Message:\n",bip32:{public:70617039,private:70615956},pubKeyHash:127,scriptHash:196,wif:255}},m={name:"ETHEREUM",bip:60,feeApi:e.env.ETHEREUM_FEE,provider:e.env.ETHEREUM_PROVIDER,chainId:1},E={name:"ETHEREUM_ROPSTEN",networkName:"ropsten",bip:60,getTranApi:e.env.ETHEREUM_ROPSTEN_GET_TRAN,getBalanceApi:e.env.ETHEREUM_ROPSTEN_GET_BALANCE,getErc20TranApi:e.env.ETHEREUM_ROPSTEN_GET_ERC20_TRAN,feeApi:e.env.ETHEREUM_ROPSTEN_FEE,provider:e.env.ETHEREUM_ROPSTEN_PROVIDER,chainId:3},f={name:"ETHEREUM_RINKEBY",networkName:"rinkeby",bip:60,getTranApi:e.env.ETHEREUM_RINKEBY_GET_TRAN,getBalanceApi:e.env.ETHEREUM_RINKEBY_GET_BALANCE,getErc20TranApi:e.env.ETHEREUM_RINKEBY_GET_ERC20_TRAN,feeApi:e.env.ETHEREUM_RINKEBY_FEE,provider:e.env.ETHEREUM_RINKEBY_PROVIDER,chainId:4},b={name:"ETHEREUM_KOVAN",networkName:"kovan",bip:60,getTranApi:e.env.ETHEREUM_KOVAN_GET_TRAN,getBalanceApi:e.env.ETHEREUM_KOVAN_GET_BALANCE,getErc20TranApi:e.env.ETHEREUM_KOVAN_GET_ERC20_TRAN,feeApi:e.env.ETHEREUM_KOVAN_FEE,provider:e.env.ETHEREUM_KOVAN_PROVIDER,chainId:42},y={name:"ETHEREUM_GOERLI",networkName:"goerli",bip:60,getTranApi:e.env.ETHEREUM_KOVAN_GET_TRAN,getBalanceApi:e.env.ETHEREUM_KOVAN_GET_BALANCE,getErc20TranApi:e.env.ETHEREUM_KOVAN_GET_ERC20_TRAN,feeApi:e.env.ETHEREUM_KOVAN_FEE,provider:e.env.ETHEREUM_KOVAN_PROVIDER,chainId:5},v={name:"REGTEST",type:"test",bip:0,discovery:e.env.BITCOIN_REGTEST_DISCOVERY,segwit:!1,feeApi:e.env.BITCOIN_REGTEST_FEE,connect:{messagePrefix:"Bitcoin Signed Message:\n",bech32:"bcrt",bip32:{public:70617039,private:70615956},pubKeyHash:111,scriptHash:196,wif:239}}}.call(this,n(9))},242:function(e,t){},244:function(e,t){},289:function(e,t){},290:function(e,t){}}]);